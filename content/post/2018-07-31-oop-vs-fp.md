---
title: "用 Visitor 模式克服 OOP 的局限"
date: 2018-07-31
draft: false
author: "Mu Xian Ming"

categories: [PL]
tags: [Java, OCaml, Visitor, OOP, FP]
---

# OOP vs FP

在把一个业务领域的模型分解成各自的编程范式的最小单位的时候，过程/函数式的方式和面向对象的方式采用的是不同的甚至相反的途径。具体采用哪种一是取决于个人喜好，二是得依据程序未来会在哪个纬度上扩展的预测。用一个简单的算术运算程序来举例：

- 程序需要应对不同的表达式，如整型数值`Int`，负数`Negate`以及加法运算`Add`
- 针对每种表达式有不同的操作，如对表达式求值`eval`，将表达式转为字符串`toString`和判断表达式是否含有零`hasZero`

这个业务问题可以用一个二维表格来表示，每个单元代表的是不同的表达式与操作之间的组合：

| | eval | toString | hasZero
--- | --- | --- | ---
Int | | |
Add | | |
Negate | | |

无论采用哪种编程范式都需要考虑如何去实现每个单元所代表的业务逻辑。

## 采用函数式的途径

在所谓的函数式语言中，通常的解决方案如下：

- 对应不同的表达式定义所需的数据类型
- 对应不同的操作定义所需的函数
- 每个函数由多个分支组成，每个分支对应于不同的数据类型（通常用 pattern-matching 来实现）

下面是 OCaml 的实现代码，之所以选择 OCaml 是因为它和 Java 类似也是一个静态类型语言。

```ocaml
exception BadResult of string

type exp =
    Int    of int
  | Negate of exp
  | Add    of exp * exp

let rec eval = function  e ->
  match e with
      Int _      -> e
    | Negate e1  -> (match eval e1 with
                        Int i -> Int (-i)
                      | _ -> raise (BadResult "non-int in negation"))
    | Add(e1,e2) -> (match (eval e1, eval e2) with
                        (Int i, Int j) -> Int (i+j)
                      | _ -> raise (BadResult "non-ints in addition"))

let rec toString = function e ->
  match e with
      Int i      -> string_of_int i
    | Negate e1  -> "-(" ^ (toString e1) ^ ")"
    | Add(e1,e2) -> "(" ^ (toString e1) ^ " + " ^ (toString e2) ^ ")"

let rec hasZero = function e ->
  match e with
      Int i      -> i = 0
    | Negate e1  -> hasZero e1
    | Add(e1,e2) -> (hasZero e1) || (hasZero e2)

;;
toString (eval (Add ((Negate (Int 5)), (Int 6))))
```

通过这段代码可以看出前述表格中的9个单元是按列来封装，每一列对应一个函数。

## 采用面向对象的途径
